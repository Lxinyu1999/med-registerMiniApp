"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBuild = exports.runDev = exports.UtsTargetExtNames = exports.UtsTarget = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const chokidar_1 = __importDefault(require("chokidar"));
const api_1 = require("./api");
const utils_1 = require("./utils");
var UtsTarget;
(function (UtsTarget) {
    UtsTarget["KOTLIN"] = "kotlin";
    UtsTarget["SWIFT"] = "swift";
})(UtsTarget = exports.UtsTarget || (exports.UtsTarget = {}));
const UtsTargetDirs = {
    [UtsTarget.KOTLIN]: 'android',
    [UtsTarget.SWIFT]: 'ios',
};
exports.UtsTargetExtNames = {
    [UtsTarget.KOTLIN]: 'kt',
    [UtsTarget.SWIFT]: 'swift',
};
function resolveDefaultOutputDir(mode, inputDir) {
    return path_1.default.resolve(inputDir, '../dist/' + mode);
}
function parseOptions(mode, target, opts) {
    const { input } = opts;
    if (!(input === null || input === void 0 ? void 0 : input.dir)) {
        throw new Error(`input.dir is required.`);
    }
    if (!fs_extra_1.default.existsSync(input.dir)) {
        throw new Error(`${input} is not found.`);
    }
    const inputSrcDir = resolveSrcDir(target, input.dir);
    if (!fs_extra_1.default.existsSync(inputSrcDir)) {
        throw new Error(`${inputSrcDir} is not found.`);
    }
    if (!opts.output) {
        opts.output = {
            dir: '',
            sourceMap: '',
            extname: exports.UtsTargetExtNames[target],
        };
    }
    if (!opts.output.dir) {
        opts.output.dir = resolveDefaultOutputDir(mode, input.dir);
    }
    opts.silent = opts.silent === true;
    return opts;
}
const EXTNAME = '.uts';
function resolveSrcDir(target, dir) {
    return path_1.default.join(dir, UtsTargetDirs[target] + '/src');
}
function initInputOptions(_, root) {
    return {
        root,
        filename: '',
    };
}
function initOutputOptions(target, outDir, sourceMap, inlineSourcesContent) {
    return {
        outDir,
        sourceMap,
        inlineSourcesContent,
        extname: exports.UtsTargetExtNames[target],
    };
}
function initOptions(target, { input: { dir: inputDir }, output: { dir: outputDir, sourceMap, inlineSourcesContent }, }) {
    const inputSrcDir = resolveSrcDir(target, inputDir);
    const outputSrcDir = resolveSrcDir(target, outputDir);
    const input = initInputOptions(target, inputSrcDir);
    const output = initOutputOptions(target, outputSrcDir, sourceMap, !!inlineSourcesContent);
    return { input, output };
}
async function watch(target, toOptions) {
    fs_extra_1.default.emptyDirSync(toOptions.output.dir);
    const { input, output } = initOptions(target, toOptions);
    const inputDir = toOptions.input.dir;
    const outputDir = toOptions.output.dir;
    const inputSrcDir = input.root;
    const outputSrcDir = output.outDir;
    const extname = toOptions.input.extname || EXTNAME;
    const silent = !!toOptions.silent;
    // 先完整编译后，再启用监听
    doBuild(target, {
        watch: true,
        input,
        output,
        inputDir,
        outputDir,
        inputSrcDir,
        outputSrcDir,
        extname,
        silent,
    }).then(() => {
        // TODO 监听动态添加的资源文件
        chokidar_1.default
            .watch('**/*' + extname, {
            cwd: inputSrcDir,
            ignored: ['**/*.d' + extname],
            ignoreInitial: true,
        })
            .on('add', (filename) => {
            buildFile(target, path_1.default.resolve(inputSrcDir, filename), input, output).then((res) => {
                if (!silent) {
                    (0, utils_1.printUtsResult)(res);
                    (0, utils_1.printDone)(true);
                }
            });
        })
            .on('change', (filename) => {
            buildFile(target, path_1.default.resolve(inputSrcDir, filename), input, output).then((res) => {
                if (!silent) {
                    (0, utils_1.printUtsResult)(res);
                    (0, utils_1.printDone)(true);
                }
            });
        })
            .on('unlink', (filename) => {
            try {
                fs_extra_1.default.unlinkSync(path_1.default.resolve(outputSrcDir, filename));
            }
            catch (e) { }
        });
    });
}
function doBuild(target, { watch, silent, extname, inputDir, inputSrcDir, outputDir, input, output, }) {
    const files = fast_glob_1.default.sync('**/*' + extname, {
        absolute: true,
        cwd: inputSrcDir,
        ignore: ['**/*.d' + extname],
    });
    return Promise.all(files.map((filename) => buildFile(target, filename, input, output).catch((error) => {
        return {
            error,
        };
    })))
        .then((res) => {
        return copyAssets(UtsTarget.KOTLIN, inputDir, outputDir, extname).then(() => res);
    })
        .then((res) => {
        !silent && (0, utils_1.printUtsResults)(res, watch);
        return res;
    });
}
function build(target, toOptions) {
    fs_extra_1.default.emptyDirSync(toOptions.output.dir);
    const { input, output } = initOptions(target, toOptions);
    const inputDir = toOptions.input.dir;
    const outputDir = toOptions.output.dir;
    const inputSrcDir = input.root;
    const outputSrcDir = output.outDir;
    const extname = toOptions.input.extname || EXTNAME;
    const silent = !!toOptions.silent;
    return doBuild(target, {
        watch: false,
        input,
        output,
        inputDir,
        outputDir,
        inputSrcDir,
        outputSrcDir,
        extname,
        silent,
    });
}
function copyAssets(target, inputDir, outputDir, extname) {
    inputDir = path_1.default.resolve(inputDir);
    outputDir = path_1.default.resolve(outputDir);
    const kotlinRootDir = path_1.default.join(inputDir, UtsTargetDirs[UtsTarget.KOTLIN]);
    const swiftRootDir = path_1.default.join(inputDir, UtsTargetDirs[UtsTarget.SWIFT]);
    return fs_extra_1.default.copy(inputDir, outputDir, {
        filter(src) {
            if (target === UtsTarget.KOTLIN) {
                if (src === swiftRootDir) {
                    return false;
                }
            }
            else if (target === UtsTarget.SWIFT) {
                if (src === kotlinRootDir) {
                    return false;
                }
            }
            if (path_1.default.basename(src).startsWith('.')) {
                return false;
            }
            if (fs_extra_1.default.lstatSync(src).isDirectory()) {
                return false;
            }
            return ![extname, '.ts'].includes(path_1.default.extname(src));
        },
    });
}
function buildFile(target, filename, input, output) {
    const toOptions = {
        input: {
            ...input,
            filename,
            namespace: '',
        },
        output: {
            ...output,
        },
    };
    const start = process.hrtime();
    return (target === UtsTarget.KOTLIN ? (0, api_1.toKotlin)(toOptions) : (0, api_1.toSwift)(toOptions)).then((res) => {
        res.time = (0, utils_1.timeEnd)(start);
        return res;
    });
}
function runDev(target, opts) {
    opts = parseOptions('dev', target, opts);
    !opts.silent && (0, utils_1.printStartup)(target, 'development');
    watch(target, opts);
}
exports.runDev = runDev;
function runBuild(target, opts) {
    opts = parseOptions('build', target, opts);
    !opts.silent && (0, utils_1.printStartup)(target, 'production');
    build(target, opts);
}
exports.runBuild = runBuild;
